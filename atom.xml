<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>展欧的空间</title>
  
  
  <link href="http://github-zhangzhenxi.github.io.git/atom.xml" rel="self"/>
  
  <link href="http://github-zhangzhenxi.github.io.git/"/>
  <updated>2022-10-07T08:44:50.398Z</updated>
  <id>http://github-zhangzhenxi.github.io.git/</id>
  
  <author>
    <name>展欧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo+butterfly主题魔改</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/07/hexo-butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/07/hexo-butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/</id>
    <published>2022-10-07T08:44:50.000Z</published>
    <updated>2022-10-07T08:44:50.398Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++容器</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/04/C++%20%E5%AE%B9%E5%99%A8/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/04/C++%20%E5%AE%B9%E5%99%A8/</id>
    <published>2022-10-04T14:56:52.000Z</published>
    <updated>2022-10-05T07:23:51.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-容器"><a href="#C-容器" class="headerlink" title="C++容器"></a>C++容器</h2><ul><li><p><strong>vector, 变长数组，倍增的思想（每当空间不够时，自动申请一个双倍的空间，并将原数组数据复制到新空间</strong>）</p><ul><li>size()  返回元素个数   <br></li><li>empty()  返回是否为空    <br></li><li>clear()  清空 <br></li><li>front()  返回vector的第一个数 <br></li><li>back()   返回vector的最后一个数 <br></li><li>push_back() 在vector 最后插入一个数 <br></li><li>pop_back()  在vector 最后删除一个数 <br></li><li>begin()   vector 第一个数<br>end()      vector 最后一个数的后面<br> 输出vector数组的值: for(vector<int>::iterator i &#x3D; a.begin(); i !&#x3D; a.end(); i++) cout &lt;&lt; *i &lt;&lt;” “;<br></li></ul></li><li><p><strong>pair&lt;int, int&gt;</strong><br>  p &#x3D; make_pair(10,”zzx”) &#x2F; p &#x3D; {20, “abc”} 构造pair函数<br>  first, 第一个元素<br>  second, 第二个元素<br>  支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</p><br></li><li><p><strong>string，字符串</strong><br>  size()&#x2F;length()  返回字符串长度<br>  empty() 字符串是否为空<br>  clear()<br>  substr(起始下标，(子串长度))  返回子串<br>  c_str()  返回字符串所在字符数组的起始地址</p><br></li><li><p><strong>queue,</strong> <strong>队列</strong><br>  size()<br>  empty()<br>  push()  向队尾插入一个元素<br>  front()  返回队头元素<br>  back()  返回队尾元素<br>  pop()  弹出队头元素</p><br></li><li><p><strong>priority_queue, 优先队列，默认是大根堆</strong><br>  size()<br>  empty()<br>  push()  插入一个元素<br>  top()  返回堆顶元素<br>  pop()  弹出堆顶元素<br>  定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;</p><br></li><li><p><strong>stack, 栈</strong><br>  size()<br>  empty()<br>  push()  向栈顶插入一个元素<br>  top()  返回栈顶元素<br>  pop()  弹出栈顶元素</p><br></li><li><p><strong>deque, 双端队列</strong><br>  size()<br>  empty()<br>  clear()<br>  front()&#x2F;back()<br>  push_back()&#x2F;pop_back()<br>  push_front()&#x2F;pop_front()<br>  begin()&#x2F;end()<br>  []</p><br></li><li><p><strong>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</strong><br>  size()<br>  empty()<br>  clear()<br>  begin()&#x2F;end()<br>  ++, – 返回前驱和后继，时间复杂度 O(logn)</p><p>  set&#x2F;multiset<br>  insert()  插入一个数<br>  find()  查找一个数<br>  count()  返回某一个数的个数<br>  erase()<br>      (1) 输入是一个数x，删除所有x   O(k + logn)<br>      (2) 输入一个迭代器，删除这个迭代器<br>  lower_bound()&#x2F;upper_bound()<br>      lower_bound(x)  返回大于等于x的最小的数的迭代器<br>      upper_bound(x)  返回大于x的最小的数的迭代器<br>  map&#x2F;multimap<br>  insert()  插入的数是一个pair<br>  erase()  输入的参数是pair或者迭代器<br>  find()<br>  []  注意multimap不支持此操作。 时间复杂度是 O(logn)<br>  lower_bound()&#x2F;upper_bound()</p></li><li><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>  和上面类似，增删改查的时间复杂度是 O(1)<br>  不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，–</p>  <br></li><li><p><strong>bitset, 圧位</strong><br>  bitset&lt;10000&gt; s;<br>  ~, &amp;, |, ^</p><blockquote><blockquote><p>, &lt;&lt;<br>  &#x3D;&#x3D;, !&#x3D;<br>  []</p></blockquote></blockquote><p>  count()  返回有多少个1</p><p>  any()  判断是否至少有一个1<br>  none()  判断是否全为0</p><p>  set()  把所有位置成1<br>  set(k, v)  将第k位变成v<br>  reset()  把所有位变成0<br>  flip()  等价于~<br>  flip(k) 把第k位取反</p></li></ul><p>注：C++为某一程序分配空间所需要的时间与空间大小无关，与申请次数有关。</p>]]></content>
    
    
    <summary type="html">C++一些常用的容器</summary>
    
    
    
    
    <category term="C/C++" scheme="http://github-zhangzhenxi.github.io.git/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>二分的思想</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/04/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/04/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-10-04T14:56:52.000Z</published>
    <updated>2022-10-05T07:25:41.780Z</updated>
    
    <content type="html"><![CDATA[<p><strong>二分的思想</strong> </p><ul><li>确定一个区间，使得目标值在区间中。</li><li>找到一个性质，满足一下两点<ul><li>性质具有二段性（在区间上的元素都能判断是否满足一个性质）</li><li>答案是二段性的分界点</li></ul></li><li>查看区间更新方式选择是否+1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;二分的思想&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定一个区间，使得目标值在区间中。&lt;/li&gt;
&lt;li&gt;找到一个性质，满足一下两点&lt;ul&gt;
&lt;li&gt;性质具有二段性（在区间上的元素都能判断是否满足一个性质）&lt;/li&gt;
&lt;li&gt;答案是二段性的分界点&lt;/l</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/04/%E6%95%B0%E8%AE%BA/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/04/%E6%95%B0%E8%AE%BA/</id>
    <published>2022-10-04T14:56:52.000Z</published>
    <updated>2022-10-05T07:25:50.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="1-质数（素数）"><a href="#1-质数（素数）" class="headerlink" title="1. 质数（素数）"></a>1. 质数（素数）</h2><br>  <p><strong>1.1 质数的判断</strong></p><p>在大于1的整数中，如果只包含1和本身这连个约数，就被称为质数（素数）</p><ul><li>质数的判定：<ul><li>试除法 O(n)</li><li>经过优化的试除法 O(qrst(n))<ul><li>质数的一个特性，约数总是成对出现，所以只需要小的约数就好，所以在循环中只需要循环到n&#x2F;i。 $d|n$ ——》$\frac{n}{d}|n$</li></ul></li></ul></li></ul><p> <strong>1.2筛法</strong></p><p> 将所有的数放在一起，把所有数的倍数删掉</p><p> - </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数论&quot;&gt;&lt;a href=&quot;#数论&quot; class=&quot;headerlink&quot; title=&quot;数论&quot;&gt;&lt;/a&gt;数论&lt;/h1&gt;&lt;h2 id=&quot;1-质数（素数）&quot;&gt;&lt;a href=&quot;#1-质数（素数）&quot; class=&quot;headerlink&quot; title=&quot;1. 质数（素数）</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BFS(广度优先搜索)和DFS(深度优先搜索)</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/BFS%E5%92%8CDFS/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/BFS%E5%92%8CDFS/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:51:22.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFS-广度优先搜索-和DFS-深度优先搜索"><a href="#BFS-广度优先搜索-和DFS-深度优先搜索" class="headerlink" title="BFS(广度优先搜索)和DFS(深度优先搜索)"></a>BFS(广度优先搜索)和DFS(深度优先搜索)</h1><ul><li><h2 id="DFS深度优先搜索"><a href="#DFS深度优先搜索" class="headerlink" title="DFS深度优先搜索"></a>DFS深度优先搜索</h2><ul><li>数据结构：栈STACK<br></li><li>空间：$$O(2^h)$$</li><li>特点： DFS是一个执着的人，当搜到叶节点才回溯，只有确定所有的路都做不了的时候我才会回头<br></li><li>通过这张图片来了解深搜的<strong>次序（DFS的顺序很重要）</strong>![[DFS.jpg]]<BR></li><li><strong>回溯</strong>：<strong>回溯就是搜索一个枝杈后返回的过程。还有回溯必须要还原现场！！！</strong><br></li><li><strong>DFS模板:</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const int N = ;//N看题目数据范围</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">bool st[N];//存节点是否被访问过</span><br><span class="line"></span><br><span class="line">int/char path[N];//存状态，可能是二维，也可能是多个</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(u == n)//无需搜索</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = ;i ;i )   cout &lt;&lt; ;//输出</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   for(int i = 0/*(也可能是别的)*/; i &lt; /*...*/;i ++ /*(或--)*/)</span><br><span class="line">&#123;</span><br><span class="line">if(/*判断的条件*/)</span><br><span class="line">&#123;</span><br><span class="line">st[i] = true;//节点被访问</span><br><span class="line"></span><br><span class="line">/*......*/;//干一些操作</span><br><span class="line"></span><br><span class="line">dfs(u + 1); // 递归下一层</span><br><span class="line"></span><br><span class="line">st[i] = false;</span><br><span class="line"></span><br><span class="line">/*......*/;//还原现场，回溯</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="BFS-宽度优先遍历"><a href="#BFS-宽度优先遍历" class="headerlink" title="BFS 宽度优先遍历"></a>BFS 宽度优先遍历</h2><h4 id="数据结构：队列QUEUE"><a href="#数据结构：队列QUEUE" class="headerlink" title="数据结构：队列QUEUE"></a>数据结构：队列QUEUE<BR></h4><h5 id="特点：BFS是一个稳重的人，每一次搜索就搜索一层，耳听六路，眼观八方。"><a href="#特点：BFS是一个稳重的人，每一次搜索就搜索一层，耳听六路，眼观八方。" class="headerlink" title="特点：BFS是一个稳重的人，每一次搜索就搜索一层，耳听六路，眼观八方。"></a>特点：BFS是一个稳重的人，每一次搜索就搜索一层，耳听六路，眼观八方。<br></h5><h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><p>一般情况下我们是用队列来实现，先进先出，使用队列保存未被检测的结点。结点按照宽度优先的次序被访问和进出队列。思路大概是这样：<br>           1.先初始化队列q；<br>          2.从起点开始访问，并且改变他的状态为已经访问；<br>           3.如果他的队列非空，取出首个元素，将它弹出！<br>           4.如果u &#x3D;  目标状态，然后对所以与u邻近的点进入队列；<br>           5.标记它已经被访问！（判重）</p><p><strong>”判重“是保证程序在有限时间内有正确输出，不出现死循环。简单理解就是，走过的路不再走，防止绕圈圈的情况出现。</strong></p><p>![[Pasted image 20220314170526.png]]</p><h3 id="一般框架"><a href="#一般框架" class="headerlink" title="一般框架"></a>一般框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">quene &lt;--- 初始状态</span><br><span class="line">while(quene 非空)</span><br><span class="line">&#123;</span><br><span class="line">   t &lt;--- 队头</span><br><span class="line">   for(扩展 t)</span><br><span class="line">   &#123;</span><br><span class="line">   ver &lt;--- 新节点</span><br><span class="line">   if(!st[ver])</span><br><span class="line">   &#123;</span><br><span class="line">队尾 &lt;--- ver  // 判重</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;//STL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">st[1] = true; // 表示1号点已经被遍历过</span><br><span class="line">q.push(1);</span><br><span class="line"></span><br><span class="line">while (q.size())</span><br><span class="line">&#123;</span><br><span class="line">    int t = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line"></span><br><span class="line">    for (int i = h[t]; i != -1; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j = e[i];</span><br><span class="line">        if (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = true; // 表示点j已经被遍历过</span><br><span class="line">            q.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BFS-广度优先搜索-和DFS-深度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索-和DFS-深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)和DFS(深度优先搜索)&quot;&gt;&lt;/a&gt;BFS(广度优先搜索)和DFS(深度优</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c++ String 用法详解 （全面解析）</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/C++%20,%20string%20%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/C++%20,%20string%20%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:47:43.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-String-用法详解-（全面解析）"><a href="#c-String-用法详解-（全面解析）" class="headerlink" title="c++ String 用法详解 （全面解析）"></a>c++ String 用法详解 （全面解析）</h1><p>一。string的初始化<br>首先要定义它的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><p>string类是一个模板类，位于名字空间std中，通常为方便使用还需要增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>然后我们先将声明一个string类型变量的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string  a;</span><br><span class="line">   a = <span class="string">&quot;hello&quot;</span>;<span class="comment">//给a赋值 “hello”</span></span><br><span class="line">   <span class="type">char</span> b[]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="function">string <span class="title">a1</span><span class="params">(a)</span></span>;<span class="comment">//调用构造函数生成a1,a1是a的复制</span></span><br><span class="line">   cout &lt;&lt; a1 &lt;&lt;endl;</span><br><span class="line">   <span class="function">string <span class="title">a2</span> <span class="params">(a,<span class="number">2</span>)</span></span>;<span class="comment">//这个意思是从a的第二个字符开始复制</span></span><br><span class="line">   cout &lt;&lt; a2 &lt;&lt;endl;</span><br><span class="line">   <span class="function">string <span class="title">a3</span><span class="params">(a,<span class="number">2</span>,<span class="number">2</span>)</span></span>;<span class="comment">//这个意思是从a的第二个字符开始复制两个字符</span></span><br><span class="line">   cout &lt;&lt; a3 &lt;&lt;endl;</span><br><span class="line">    <span class="function">string <span class="title">a4</span><span class="params">(b)</span></span>;<span class="comment">//这是以b字符串作为初值</span></span><br><span class="line">    cout &lt;&lt; a4 &lt;&lt;endl;</span><br><span class="line">    <span class="function">string <span class="title">a5</span><span class="params">(b,<span class="number">3</span>)</span></span>;<span class="comment">//这是将b字符串的前三个作为初值</span></span><br><span class="line">    cout &lt;&lt; a5 &lt;&lt;endl;</span><br><span class="line">    <span class="function">string <span class="title">a6</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//这是以5个字符c作为初值</span></span><br><span class="line">    cout &lt;&lt; a6 &lt;&lt;endl;</span><br><span class="line">    <span class="function">string <span class="title">a7</span><span class="params">(a.begin(),a.begin()+<span class="number">2</span>)</span></span>;<span class="comment">//以区间a.begin()到a.begin()+2之间的字符为初值</span></span><br><span class="line">    cout &lt;&lt; a7 &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20200412104220298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczMTAwNQ==,size_16,color_FFFFFF,t_70" alt="结果"><br>二。string的比较操作，首先对于string型的字符串，它的比较是很简单的，不用去记那些c中字符串的<br>比较函数，只要用&gt;,&lt;,&#x3D;&#x3D;,&gt;&#x3D;这些数学符号就可以。还可以可以用+或者+&#x3D;操作符连接两个字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string  a;</span><br><span class="line">    a = <span class="string">&quot;hello&quot;</span>;<span class="comment">//给a赋值 “hello”</span></span><br><span class="line">  <span class="keyword">if</span>(a==<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="string">&quot;world&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;You win.&quot;</span>&lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You failed.&quot;</span>&lt;&lt; endl;</span><br><span class="line">  a+=<span class="string">&quot; world&quot;</span>;</span><br><span class="line">  cout &lt;&lt; a&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20200412105211979.png" alt="在这里插入图片描述"><br>三。string的查找操作<br>查找函数是a.find(),里面可以是一个字符，也可以是字符串，如果找到返回第一个出现的位置，如果找<br>不到返回-1这个是从前往后查找<br>还有一个是a.rfind(),这个和find()的操作一样，返回值也一样，这不过他是从后往前查找<br>find函数：从头查找</p><p>str.find(‘A’)——查找 ‘A’<br>str.find(“ABC”)——查找 “ABC”<br>int n&#x3D;s4.find(“ABC”); s4：ABCD -&gt; n &#x3D; 0</p><p>str.find(‘B’,1)——从 位置1 处，查找’B’<br>str.find(“ABC”,1,2)——从 位置1 处，开始查找 ‘ABC’ 的前 2个 字符<br>rfind函数：从尾部查找</p><p>str.rfind(‘A’)——查找 ‘A’<br>str.rfind(“ABC”)——查找 “ABC”<br>int n&#x3D;s4.rfind(“ABC”); s4：AAAABCD -&gt; n &#x3D; 3</p><p>str.rfind(‘B’,1)——从 位置1 处，向前查找’B’<br>str.rfind(“ABC”,1,2)——从 位置1 处，开始向前查找 ‘ABC’ 的前 2个 字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">string  a=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  b=a.<span class="built_in">find</span>(<span class="string">&quot;o&quot;</span>);<span class="comment">//查找字符o在a中的第一个位置</span></span><br><span class="line">  cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">  b=a.<span class="built_in">find</span>(<span class="string">&quot;ell&quot;</span>);<span class="comment">//查找字符串&quot;ell&quot;在字符串a中第一次出现的位置</span></span><br><span class="line">  cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">  b=a.<span class="built_in">find</span>(<span class="string">&quot;elu&quot;</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//从下标0开始查找&quot;elu&quot;字符串的前两个字符</span></span><br><span class="line">  cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">  b=a.<span class="built_in">find</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">  cout &lt;&lt; b &lt;&lt;endl;<span class="comment">//当找不到时返回-1</span></span><br><span class="line">   b=a.<span class="built_in">find</span>(<span class="string">&quot;o&quot;</span>,<span class="number">5</span>);<span class="comment">//从下标5开始往后查找查找</span></span><br><span class="line">   cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">    b=a.<span class="built_in">rfind</span>(<span class="string">&quot;l&quot;</span>);<span class="comment">//查找字符l在a中从后往前的第一个位置</span></span><br><span class="line">  cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">   b=a.<span class="built_in">rfind</span>(<span class="string">&quot;ell&quot;</span>);<span class="comment">//查找字符串&quot;ell&quot;在字符串a中从后往前第一次出现的位置</span></span><br><span class="line">  cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line">   b=a.<span class="built_in">rfind</span>(<span class="string">&quot;l&quot;</span>,<span class="number">2</span>);<span class="comment">//从第五个字符开始向前查找</span></span><br><span class="line">   cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找s 中flag 出现的所有位置。</span></span><br><span class="line">   <span class="type">char</span> flag[]=<span class="string">&quot;l&quot;</span>;</span><br><span class="line">   <span class="type">int</span> position=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>((position=a.<span class="built_in">find</span>(flag,position))!=<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;position  &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;position&lt;&lt;endl;</span><br><span class="line">       position++;</span><br><span class="line">       i++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20200412112700776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczMTAwNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>四。string字符串和数值的转换<br>在做题中我们总会遇到一些整数转字符串或者字符串转整数类型的操作，这里就用string实现这一操<br>作</p><p>1.string和数值转换 转换类型<br>to_string(val) 把val转换成string<br>stoi(s,p,b) 把字符串s从p开始由b进制转化为十进制的int<br>stol(s,p,b) 把字符串s从p开始由b进制转化为十进制的long<br>stoul(s,p,b) 把字符串s从p开始由b进制转化为十进制的unsigned long<br>stoll(s,p,b) 把字符串s从p开始由b进制转化为十进制的long long<br>stoull(s,p,b) 把字符串s从p开始由b进制转化为十进制的unsigned long long<br>stof(s,p) 把字符串s从p开始转换成float<br>stod(s,p) 把字符串s从p开始转换成double<br>stold(s,p) l把字符串s从p开始转换成long double</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string s=<span class="string">&quot;222.22&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s=&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> a = <span class="number">222</span>;</span><br><span class="line"><span class="type">int</span> ot = <span class="built_in">stoi</span>(s,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> ol = <span class="built_in">stol</span>(s,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="type">float</span> of = <span class="built_in">stof</span>(s,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> od = <span class="built_in">stod</span>(s,<span class="number">0</span>); </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;ot=&quot;</span>&lt;&lt;ot&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;ol=&quot;</span>&lt;&lt;ol&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;of=&quot;</span>&lt;&lt;of&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;od=&quot;</span>&lt;&lt;od&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200412114246970.png" alt="在这里插入图片描述"><br>2.<br>数值转换为字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">123.32</span>;</span><br><span class="line">    string res;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; a;</span><br><span class="line">    ss &gt;&gt; res;<span class="comment">//或者 res = ss.str();</span></span><br><span class="line">    cout&lt;&lt;res; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020041211425714.png" alt="在这里插入图片描述"></p><p>五。string常用成员函数<br>assign函数：<br>str.assign(“ABC”)——清空字符串，并设置为 “ABC”<br>str.assign(“ABC”,2)——清空字符串，并设置为”AB”，保留两个字符<br>str.assign(“ABC”,1,1)——清空字符串，设置为 “ABC” 中的从 位置1 开始，保留 1个 字符<br>str.assign(5，‘A’)——清空字符串，然后字符串设置为 5个 ‘A’<br>str.length()——求字符串长度<br>str.size()——和 length() 一样<br>str.capacity()——获取容量，包含了不用增加内存就能使用的字符数<br>str.reasize(10)——设置当前 str 的大小为10，若大小大与当前串的长度，\0 来填充<br>str.reasize(10,char c)——设置当前 str 的大小为10，若大小大与当前串的长度，字0符c 来填充<br>str.reserve(10)——设置str的容量 10，不会填充数据<br>str.swap(str1)——交换 str1 和 str 的字符串<br>str.push_back(‘A’)——在str末尾添加一个字符 ‘A’ ，参数必须是字符形式<br>str.append(“ABC”)——在str末尾添加一个字符串 “ABC”，参数必须是字符串形式<br>insert函数方法：</p><p>str.insert(2,3,‘A’)——在str下标为2的位置添加 3个 字符’A’<br>str.insert(2,“ABC”)——在str下标为2的位置添加 字符串 “ABC”<br>str.insert(2,“ABC”,1)——在str下标为2的位置添加 字符串 “ABC” 中 1个 字符<br>str.insert(2,“ABC”,1,1)——在str下标为2的位置添加 字符串 “ABC” 中从位置 1 开始的 1 个字符<br>注：上个函数参数中加粗的 1 ，可以是 string::npos，这时候最大值，从 位置1 开始后面的全部字符</p><p>str.insert( iterator pos, size_type count, CharT ch )——在 str 中，迭代器指向的 pos位置 插入 count个 字符 ch<br>s4.insert(++str1.begin(),2,‘a’); 结果：s4：ABCD -&gt; AaaBCD</p><p>str.insert( iterator pos, InputIt first, InputIt last )——在 str 中，pos位置 插入 str1 的 开始位置 到 结束为止<br>s4.insert(s4.begin(),str1.begin(),str1.end()); 结果：s4：ABCD str1：abc -&gt; abcABCD</p><p>str.erase(2)——删除 下标2 的位置开始，之后的全删除<br>str.erase(2,1)——删除 下标2 的位置开始，之后的 1个 删除<br>str.clear()——删除 str 所有<br>str.replace(2,4,“abcd”)——从 下标2 的位置，替换 4个字节 ，为”abcd”<br>str.empty()——判空（空返回1，非空返回0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">string a=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="string">&quot;ABC&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="string">&quot;ABC&quot;</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    d=a.<span class="built_in">length</span>();</span><br><span class="line">    cout &lt;&lt;d &lt;&lt;endl;</span><br><span class="line">    d=a.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt;d &lt;&lt;endl;</span><br><span class="line">    string b=<span class="string">&quot;BBBBB&quot;</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; b &lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; b &lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">append</span>(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;ABC&quot;</span>,<span class="number">1</span>) ;</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;ABC&quot;</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a=b;</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a=b;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a=b;</span><br><span class="line">    a.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">    a=b;</span><br><span class="line">    d=a.<span class="built_in">empty</span>();</span><br><span class="line">    cout &lt;&lt; d &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200412115823939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczMTAwNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-String-用法详解-（全面解析）&quot;&gt;&lt;a href=&quot;#c-String-用法详解-（全面解析）&quot; class=&quot;headerlink&quot; title=&quot;c++ String 用法详解 （全面解析）&quot;&gt;&lt;/a&gt;c++ String 用法详解 （全面解析）&lt;/</summary>
      
    
    
    
    
    <category term="C/C++" scheme="http://github-zhangzhenxi.github.io.git/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/KMP%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%89/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/KMP%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%89/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:48:14.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>对于字符串查找，对于数值查找则在[[二分查找（数值查找）]]</p><h3 id="字符串匹配算法的朴素版本"><a href="#字符串匹配算法的朴素版本" class="headerlink" title="字符串匹配算法的朴素版本"></a>字符串匹配算法的朴素版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">N &gt; M</span><br><span class="line">int S[N], P[M]; S是原传，P是母版串</span><br><span class="line">for(int i=1;i&lt;=n;i++) //枚举当前起点，看是否成功</span><br><span class="line">&#123;</span><br><span class="line">bool flag = true;//是否成功</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">if(s[i] != p[j])</span><br><span class="line">&#123;</span><br><span class="line">flag = false;// 失败</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这种暴力的做法时间复杂度会很高（最坏：$O(m * n)$），所以在此基础上来优化暴力算法。<br></li></ol><h3 id="那KMP算法是怎样的呢？"><a href="#那KMP算法是怎样的呢？" class="headerlink" title="那KMP算法是怎样的呢？"></a>那KMP算法是怎样的呢？</h3><ol><li><p>首先让我们了解一下概念<br> 前缀：不包含最后一个字符的其他字符任意组合<br><br> 后缀：不包含第一个字符的其他字符任意组合<br><br> 相同前后缀：一个字符串中前缀和后缀中的一对，如果相等，则称有一个相同前后缀<br><br> <strong>最长相同前后缀</strong>：在相同前后缀中长度最长的<br><br> <strong>NEXT表</strong>：当字符串长度从 1 的最长相同前后缀，长度为 2 的最长相同前后缀，……一次类推。表里的数值是当在位置 $A$ 上的字符不匹配后，则跳转（$NEXT$表中$A - 1$的位置提供的数值）响应的位置重新比较。<br> </p></li><li><p>当我们匹配字符串出现不匹配的时候，则跳转到相应位置重新比较（$NEXT$表中$A - 1$的位置提供的数值）<br></p></li></ol><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 求Next数组：</span><br><span class="line">// s[]是长文本，p[]是模式串, m是s的长度，n是p的长度（在主串中找模式串）</span><br><span class="line">for (int i = 2, j = 0; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];</span><br><span class="line">    if (p[i] == p[j + 1]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 匹配</span><br><span class="line">for (int i = 1, j = 0; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];</span><br><span class="line">    if (s[i] == p[j + 1]) j ++ ;</span><br><span class="line">    if (j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        // 匹配成功后的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h2 id="831-KMP字符串"><a href="#831-KMP字符串" class="headerlink" title="831. KMP字符串"></a>831. KMP字符串</h2><p>给定一个模式串 $S$，以及一个模板串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串 $P$ 在模式串 $S$ 中多次作为子串出现。</p><p>求出模板串 $P$ 在模式串 $S$ 中所有出现的位置的起始下标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 $N$，表示字符串 $P$ 的长度。</p><p>第二行输入字符串 $P$。</p><p>第三行输入整数 $M$，表示字符串 $S$ 的长度。</p><p>第四行输入字符串 $S$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1 \le N \le 10^5$<br>$1 \le M \le 10^6$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">char a[N],b[N];</span><br><span class="line">int ne[N];</span><br><span class="line">int  n,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">cin&gt;&gt;n&gt;&gt;a+1&gt;&gt;m&gt;&gt;b+1;</span><br><span class="line">    </span><br><span class="line">for(int i=2,j=0;i&lt;=n;i++)&#123;</span><br><span class="line">    </span><br><span class="line">   while(j&amp;&amp;a[i]!=a[j+1])j=ne[j];</span><br><span class="line">       </span><br><span class="line">   if(a[i]==a[j+1])j++;</span><br><span class="line">       </span><br><span class="line">   ne[i]=j;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">for(int i=1,j=0;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;b[i]!=a[j+1])j=ne[j];</span><br><span class="line">        </span><br><span class="line">if(b[i]==a[j+1])j++;</span><br><span class="line">    </span><br><span class="line">if(j==n)&#123;</span><br><span class="line">            cout&lt;&lt;i-n&lt;&lt;&quot; &quot;;</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KMP&quot;&gt;&lt;a href=&quot;#KMP&quot; class=&quot;headerlink&quot; title=&quot;KMP&quot;&gt;&lt;/a&gt;KMP&lt;/h1&gt;&lt;p&gt;对于字符串查找，对于数值查找则在[[二分查找（数值查找）]]&lt;/p&gt;
&lt;h3 id=&quot;字符串匹配算法的朴素版本&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>String.h头文件（零碎）</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/String.h%20%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/String.h%20%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:51:17.354Z</updated>
    
    <content type="html"><![CDATA[<p>strlen(字符数组)</p><pre><code>获取第一个&#39;/0&#39;前的字符的数量</code></pre><p>strcmp（字符数组1， 字符数组2）</p><pre><code>返回两个字符串比较的结果字符串1 &lt; 字符串2 返回 负整数字符串1 = 字符串2 返回 0字符串1 &gt; 字符串2 返回 正整数</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;strlen(字符数组)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;获取第一个&amp;#39;/0&amp;#39;前的字符的数量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strcmp（字符数组1， 字符数组2）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回两个字符串比较的结果
字符串1 &amp;lt; 字符串2 返回 </summary>
      
    
    
    
    
    <category term="C/C++" scheme="http://github-zhangzhenxi.github.io.git/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%B0%E5%80%BC%E6%9F%A5%E6%89%BE%EF%BC%89/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%B0%E5%80%BC%E6%9F%A5%E6%89%BE%EF%BC%89/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:49:32.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><hr><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><ul><li><p>二分整数模板一共有两个，分别适用于不同情况。<br></p></li><li><p>用于整数的查找，对于字符串在[[KMP（字符串匹配）]]<BR></p></li><li><p>算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l &#x3D; r时，我们就找到了目标值。</p></li><li><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><ul><li><p>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r &#x3D; mid或者l &#x3D; mid + 1;，计算mid时不需要加1。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_1(int q[], int l, int r, int x)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (x &lt;= q[mid]) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r &#x3D; mid - 1或者l &#x3D; mid;，此时为了防止死循环，计算mid时需要加1。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_2(int q[], int l, int r, int x)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">        if (x &gt;= q[mid]) l = mid;</span><br><span class="line">        else r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h5><p>  <strong>第一个模板是从左到右找（当满足条件后，移动的是右边界）找到的是第一个小于等于指定数的位置，第二个模板是从右往左找（满足条件后移动的是左边界）找第一个大于等于指定数位置！！！</strong><br>模板一中mid不用加一是因为当出现 $l &#x3D; r + 1$ 时 $mid &#x3D; (l + 1) &#x2F; 2$是<strong>下取整</strong>，所以不会构成死循环！！</p></li><li><h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><p>  这两个模板都必须使用在<strong>升序</strong>的数列中<br>  <img src="app://local/D%3A%5C%E5%AD%A6%E4%B9%A0%5C%E5%BA%93%5C%E5%9B%BE%E7%89%87%5CPasted%20image%2020220126110451.png?1643166291727" alt="Pasted image 20220126110451.png"></p></li><li><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h5><ol><li>循环必须是l &lt; r  </li><li>if判断条件看是不是不满足条件， 然后修改上下界  </li><li>若if else后是r &#x3D; mid - 1，则前面mid 语句要加1  </li><li>出循环一定是l &#x3D;&#x3D; r，所以l和r用哪个都可以</li></ol></li><li><h5 id="总结（二分只有下面两种情况）"><a href="#总结（二分只有下面两种情况）" class="headerlink" title="总结（二分只有下面两种情况）"></a><strong>总结</strong>（二分只有下面两种情况）</h5><ol><li>找大于等于给定数的第一个位置 模板2（满足某个条件的第一个数）  </li><li>找小于等于给定数的最后一个数 模板1（满足某个条件的最后一个数）  <br></li></ol></li></ul></li></ul><h2 id="STL中的二分函数"><a href="#STL中的二分函数" class="headerlink" title="STL中的二分函数"></a>STL中的二分函数</h2><h4 id="lower-bound：查找第一个大于或等于某个元素的位置。"><a href="#lower-bound：查找第一个大于或等于某个元素的位置。" class="headerlink" title="lower_bound：查找第一个大于或等于某个元素的位置。"></a><strong>lower_bound：查找第一个大于或等于某个元素的位置。</strong></h4><p>a.函数模板：lower_bound(arr[],arr[]+size ,  indx):<br>b.参数说明：<br> arr[]： 数组首地址<br> size：数组元素个数<br> indx:需要查找的值<br>c.函数功能：  函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置(注意是地址)。如果所有元素都小于val，则返回last的位置</p><h4 id="upper-bound：查找第一个大于某个元素的位置。"><a href="#upper-bound：查找第一个大于某个元素的位置。" class="headerlink" title="upper_bound：查找第一个大于某个元素的位置。"></a><strong>upper_bound：查找第一个大于某个元素的位置。</strong></h4><p>a.函数模板：upper_bound(arr[],arr[]+size ,  indx):<br>b.参数说明：<br> arr[]： 数组首地址<br> size：数组元素个数<br> indx:需要查找的值<br>c.函数功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置<br> 例如：一个数组number序列1,2,2,4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置,同样，<strong>如果插入元素大于数组中全部元素，返回的是last。(注意：数组下标越界)</strong><br> 返回查找元素的最后一个可安插位置，也就是“元素值&gt;查找值”的第一个元素的位置 。</p><h4 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h4><p>binary_search()</p><ul><li><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h4><pre><code>  # 789. 数的范围</code></pre>  给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。  对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。  如果数组中不存在该元素，则返回 <code>-1 -1</code>。<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5>  第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。  第二行包含 $n$ 个整数（均在 $1 \sim 10000$ 范围内），表示完整数组。  接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5>  共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。  如果数组中不存在该元素，则返回 <code>-1 -1</code>。<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5>  $1 \le n \le 100000$<br>  $1 \le q \le 10000$<br>  $1 \le k \le 10000$<h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h5 id="题解："><a href="#题解：" class="headerlink" title="题解："></a><strong>题解：</strong></h5>  ![[Pasted image 20220125131416.png]]</li></ul><hr><hr><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>浮点数二分的模板只有一个，因为浮点二分不需要注意边界问题（浮点数的除没有取整的步骤）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质</span><br><span class="line"></span><br><span class="line">double bsearch_3(double l, double r, double x)</span><br><span class="line">&#123;</span><br><span class="line">    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求</span><br><span class="line">//注意循环条件</span><br><span class="line">    while (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        double mid = (l + r) / 2;</span><br><span class="line">        if (check(mid)) r = mid;</span><br><span class="line">        else l = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return l;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;整数二分&quot;&gt;&lt;a href=&quot;#整数二分&quot; class=&quot;headerlink&quot; title=&quot;整数二分</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始了解 Trie树</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3%20Trie%E6%A0%91%E5%8F%8A%E7%AE%80%E6%98%93%E6%A8%A1%E6%9D%BF/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3%20Trie%E6%A0%91%E5%8F%8A%E7%AE%80%E6%98%93%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:25:16.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从零开始了解-Trie树"><a href="#从零开始了解-Trie树" class="headerlink" title="从零开始了解 Trie树"></a>从零开始了解 <strong>Trie树</strong></h2><ul><li><p><strong>Trie树是什么</strong><br>  高效地存储和查找字符串集合的数据结构  </p></li><li><p><strong>首先要知道它的作用</strong><br> Trie是能够进行快速检索的多叉树结构</p></li><li><p><strong>知道事物的由来有利于更深入的理解</strong><br> Trie树是哈希树的变种，但查找效率比哈希树高</p></li><li><p><strong>Trie树的特点是什么</strong></p><ol><li>根节点不包含字符，除了根节点外每一个节点就包含一个字符。</li><li>从根节点到某一节点，路径上的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不同。</li></ol></li></ul><hr><h2 id="Trie-树的操作"><a href="#Trie-树的操作" class="headerlink" title="Trie 树的操作"></a>Trie 树的操作</h2><ul><li>Trie树<strong>存储</strong>：Trie树在某些节点添加一个标志用来表明从根节点到此为一个被存储的字符串。</li><li>Trie树<strong>查找</strong>：Trie树检索在是否存储过。</li></ul><hr><p>##模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int son[N][26], cnt[N], idx;</span><br><span class="line">// 0号点既是根节点，又是空节点</span><br><span class="line">// son[][]存储树中每个节点的子节点</span><br><span class="line">// cnt[]存储以每个节点结尾的单词数量，从a 到 z一共26个单词，下标为0表示a，依次类推，进行位置和字母的绑定</span><br><span class="line"></span><br><span class="line">// 插入一个字符串</span><br><span class="line">void insert(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;  </span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;       //u表示在一行中的位置，通过位置来标明字符</span><br><span class="line">        if (!son[p][u]) son[p][u] = ++ idx; //idx的递增是到下一层，然后通过位置表示具体的字符，组成Trie树</span><br><span class="line">        p = son[p][u];  </span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询字符串出现的次数</span><br><span class="line">int query(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https://www.acwing.com/blog/content/404/</span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure><hr><h2 id="Trie树和哈希树的异同"><a href="#Trie树和哈希树的异同" class="headerlink" title="Trie树和哈希树的异同"></a>Trie树和哈希树的异同</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从零开始了解-Trie树&quot;&gt;&lt;a href=&quot;#从零开始了解-Trie树&quot; class=&quot;headerlink&quot; title=&quot;从零开始了解 Trie树&quot;&gt;&lt;/a&gt;从零开始了解 &lt;strong&gt;Trie树&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;str</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://github-zhangzhenxi.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从零了解堆</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3%E5%A0%86%E5%8F%8A%E7%AE%80%E6%98%93%E6%A8%A1%E6%9D%BF/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3%E5%A0%86%E5%8F%8A%E7%AE%80%E6%98%93%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:25:34.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从零了解堆"><a href="#从零了解堆" class="headerlink" title="从零了解堆"></a>从零了解堆</h2><ul><li><strong>什么是堆</strong><br>  一个完全二叉树</li><li><strong>堆的性质</strong><br>  每个节点都小于其左右子节点</li><li><strong>堆的存储</strong><br>  根节点为1，并每一个节点其左儿子为2x（所以下标不能从0开始）、右儿子为2x + 1.</li><li><strong>堆的基本操作</strong><ol><li>down(x) ：如果把一个数变大，则这个数下沉</li><li>up(x)：把一个数变小，这个数上升</li></ol></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="line">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="line">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="line">int h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line">// 交换两个点，及其映射关系</span><br><span class="line">void heap_swap(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t = u;</span><br><span class="line">    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;</span><br><span class="line">    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;</span><br><span class="line">    if (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, u / 2);</span><br><span class="line">        u &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(n)建堆</span><br><span class="line">for (int i = n / 2; i; i -- ) down(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：https://www.acwing.com/blog/content/404/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从零了解堆&quot;&gt;&lt;a href=&quot;#从零了解堆&quot; class=&quot;headerlink&quot; title=&quot;从零了解堆&quot;&gt;&lt;/a&gt;从零了解堆&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;什么是堆&lt;/strong&gt;&lt;br&gt;  一个完全二叉树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://github-zhangzhenxi.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从零了解并查集</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E7%AE%80%E6%98%93%E6%A8%A1%E6%9D%BF/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E7%AE%80%E6%98%93%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:25:26.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从零了解并查集"><a href="#从零了解并查集" class="headerlink" title="从零了解并查集"></a>从零了解并查集</h2><ul><li><p><strong>并查集是什么</strong><br>  并查集，是一种判断“远房亲戚”的算法</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</span><br></pre></td></tr></table></figure></li><li><p><strong>并查集的作用</strong><br>  “并”：把两个处在同一个连通分量的结点给并到一起.<br>  “查”：查找一个结点的根节点（询问两个元素是否在同一个集合里）<br>  “并”的时候需要用到“查”</p>  <br></li><li><p><strong>并查集的基本原理</strong><br>每一个集合用一个树的形式来维护所有的集合，根节点的编号是当前集合的编号，每一个节点都存储其父节点是谁（p[x]表示x的父节点，树根的父节点是它自身）</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2></li></ul><p> (1)朴素并查集：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int p[N]; //存储每个点的祖宗节点</span><br><span class="line"></span><br><span class="line">// 返回x的祖宗节点并路径压缩</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化，假定节点编号是1~n</span><br><span class="line">for (int i = 1; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">// 合并a和b所在的两个集合：</span><br><span class="line">p[find(a)] = find(b);</span><br></pre></td></tr></table></figure></p><p>(2)维护size的并查集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int p[N], size[N];</span><br><span class="line">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><span class="line"></span><br><span class="line">// 返回x的祖宗节点</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化，假定节点编号是1~n</span><br><span class="line">for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合并a和b所在的两个集合：</span><br><span class="line">size[find(b)] += size[find(a)];</span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3)维护到祖宗节点距离的并查集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    int p[N], d[N];</span><br><span class="line">    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><span class="line"></span><br><span class="line">    // 返回x的祖宗节点</span><br><span class="line">    int find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            int u = find(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        return p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化，假定节点编号是1~n</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 合并a和b所在的两个集合：</span><br><span class="line">    p[find(a)] = find(b);</span><br><span class="line">    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https://www.acwing.com/blog/content/404/</span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从零了解并查集&quot;&gt;&lt;a href=&quot;#从零了解并查集&quot; class=&quot;headerlink&quot; title=&quot;从零了解并查集&quot;&gt;&lt;/a&gt;从零了解并查集&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;并查集是什么&lt;/strong&gt;&lt;br&gt;  并查集，是一种判断“远房</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://github-zhangzhenxi.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>位运算及标准模版库</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:51:22.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算及标准模版库"><a href="#位运算及标准模版库" class="headerlink" title="位运算及标准模版库"></a>位运算及标准模版库</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li><p>1、位运算符</p><blockquote><p>这些位运算只能用于整型操作数，即只能用于带符号或无符号的char、short、int、与long类型。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①按位与（&amp;）</span><br><span class="line">②按位或（|）</span><br><span class="line">③按位异或（^）</span><br><span class="line">④取反（~）</span><br><span class="line">⑤左移（&lt;&lt;）n&lt;&lt;1=2*n,1&lt;&lt;n=2^n</span><br><span class="line">⑥右移（&gt;&gt;）n&gt;&gt;1=n/2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优先级：</span><br><span class="line">加减   移位    比较大小     位与   异或   位或</span><br><span class="line">+,-    &lt;&lt;,&gt;&gt;   &gt;,&lt;,==,!=     &amp;      ^      | </span><br></pre></td></tr></table></figure><ul><li>2、位运算的应用举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①高效代替布尔型数组</span><br><span class="line">②表示集合、搜索算法中的状态判重（hash）</span><br><span class="line">③动态规划算法中的状态压缩</span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><blockquote><p>使用vector，需添加<code>#include&lt;vector&gt;</code>,同时要有using namespace std。</p></blockquote><ul><li>1、定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;typename&gt; name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a;//长度不固定的一维整型数组</span><br><span class="line">vector&lt;double&gt; b;//长度不固定的一维浮点型数组</span><br><span class="line">vector&lt;node&gt; student;//node为已经定义了的结构体</span><br><span class="line">vector&lt;int&gt; c[100];//一维长度固定为100,另一维长度不固定的二维数组，</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; a;//一个两位长度都不固定的二维数组</span><br></pre></td></tr></table></figure><ul><li>2、访问</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①下标访问：对于vector&lt;int&gt; v,使用v[idx]访问它的第idx个元素</span><br><span class="line">0&lt;=idx&lt;=v.size()-1,v.size()表示vector中元素个数</span><br><span class="line"></span><br><span class="line">②迭代器访问：定义：</span><br><span class="line">vector&lt;typename&gt;::iterator it;</span><br><span class="line">可以通过*it来访问vector里的元素。迭代器也可以进行自加、自减操作。</span><br><span class="line">v.begin()为取v的首元素地址，v.end()为取尾元素地址的下一个地址。</span><br></pre></td></tr></table></figure><ul><li>3、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">①push_back()</span><br><span class="line">push_back(X)在vector后添加一个元素x。</span><br><span class="line"></span><br><span class="line">②size()</span><br><span class="line">一维：vector中元素个数</span><br><span class="line">二维：vector中第二维元素个数</span><br><span class="line">用resize(n)重设数组大小</span><br><span class="line"></span><br><span class="line">③pop_back()</span><br><span class="line">删除vector的尾元素</span><br><span class="line"></span><br><span class="line">④clear(n)</span><br><span class="line">清空vector中的所有元素</span><br><span class="line"></span><br><span class="line">⑤insert()</span><br><span class="line">insert(it,x)用来向vector任意迭代器it处插入一个元素x</span><br><span class="line"></span><br><span class="line">⑥erase()</span><br><span class="line">erase(it):删除it处元素</span><br><span class="line">earse(left right):删除[left,right)内所有元素</span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><blockquote><p>stack翻译为栈，是一个”后进先出“的容器。使用时需添加<code>include&lt;stack&gt;</code>,同时要有using namespace std。</p></blockquote><ul><li>1、定义：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;typename&gt; name;//typename可以是任何基本类型或者容器，name是栈的名字</span><br></pre></td></tr></table></figure><ul><li>2、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">①push()</span><br><span class="line">push(x)用来将x压栈</span><br><span class="line"></span><br><span class="line">②top()</span><br><span class="line">获得栈顶元素</span><br><span class="line"></span><br><span class="line">③pop()</span><br><span class="line">弹出栈顶元素</span><br><span class="line"></span><br><span class="line">④empty()</span><br><span class="line">检测stack是否为空，空返回true，否则返回false</span><br><span class="line"></span><br><span class="line">⑤size()</span><br><span class="line">返回stack内元素个数</span><br></pre></td></tr></table></figure><ul><li>只能通过函数<code>top()</code>和<code>pop()</code>来访问栈顶元素。</li></ul><h2 id="queue和priority-queue"><a href="#queue和priority-queue" class="headerlink" title="queue和priority_queue"></a>queue和priority_queue</h2><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><blockquote><p>queue翻译为队列，是一个”先进先出“的容器。使用时需添加<code>include&lt;queue&gt;</code>,同时要有using namespace std。</p></blockquote><ul><li>1、定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;typename&gt; name;</span><br></pre></td></tr></table></figure><ul><li>2、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">①push()</span><br><span class="line">push(x)用来将x入队</span><br><span class="line"></span><br><span class="line">②front()</span><br><span class="line">获得队首元素</span><br><span class="line"></span><br><span class="line">③back()</span><br><span class="line">获得队尾元素</span><br><span class="line"></span><br><span class="line">④pop()</span><br><span class="line">让队首元素出队</span><br><span class="line"></span><br><span class="line">⑤empty()</span><br><span class="line">检测queue是否为空</span><br><span class="line"></span><br><span class="line">⑥size()</span><br><span class="line">返回queue内元素的个数</span><br></pre></td></tr></table></figure><ul><li>queue只能通过函数<code>front()</code>来访问队首元素，或通过函数<code>back()</code>来访问队尾元素。一般应用在<strong>宽搜</strong>中。在使用<code>front()</code>和<code>pop()</code>前，必须用<code>empty()</code>判断队列是否为空，否则可能因为队空而出现错误。</li></ul><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><blockquote><p>priority_queue翻译为优先队列，一般用来解决一些贪心问题，其底层是用“堆”来实现的。使用时需添加<code>include&lt;queue&gt;</code>,同时要有using namespace std。</p></blockquote><ul><li>1、定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;typename&gt; name;</span><br></pre></td></tr></table></figure><ul><li>和queue不一样的是，priority_queue没有<code>front()</code>和<code>back()</code>，而只能通过<code>top()</code>或<code>pop()</code>访问队首元素（也称堆顶元素），也就是优先级最高的元素。</li><li>2、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①push()</span><br><span class="line">push(x)是将x加入优先队列</span><br><span class="line"></span><br><span class="line">②top()</span><br><span class="line">获得队首元素（堆顶元素）</span><br><span class="line"></span><br><span class="line">③pop()</span><br><span class="line">让队首元素（堆顶元素）出队</span><br></pre></td></tr></table></figure><ul><li>使用top()必须用empty()判断优先队列是否为空，否则有可能出错。</li><li>2、元素优先级的设置<br>优先队列对它们的优先级设置一般是数字越大的优先级越高（对于char，则是字典序最大的）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下两种优先队列的定义是等价的：</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;</span><br></pre></td></tr></table></figure><h2 id="map和pair"><a href="#map和pair" class="headerlink" title="map和pair"></a>map和pair</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote><p>map翻译为映射。使用时需添加<code>include&lt;map&gt;</code>,同时要有using namespace std。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map的用途有以下情形：</span><br><span class="line">①需要建立字符（串）与整数之间的映射，使用map可以减少的代码量。</span><br><span class="line">②判断大整数（比如几千位）或者其他类型数据是否存在，可以把map当布尔型数组使用（哈希表）。</span><br><span class="line">③字符串与字符串之间的映射。</span><br></pre></td></tr></table></figure><p>定义一个map的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; name;//typename1是映射前的类型（键key），typename2是映射后的类型（值value），name为映射的名字。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt; a;</span><br><span class="line">map&lt;string,int&gt; a;//不能使用char</span><br><span class="line">map&lt;set&lt;int&gt;,string&gt;mp;</span><br></pre></td></tr></table></figure><ul><li>1、访问<br>①通过下标访问：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先定义“map&lt;char,int&gt; mp”,然后就可以通过mp[&#x27;c&#x27;]的方式来访问它对应的元素。</span><br></pre></td></tr></table></figure><ul><li>2、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">①find()</span><br><span class="line">find(key)是返回键为key的映射的迭代器。</span><br><span class="line"></span><br><span class="line">②size()</span><br><span class="line">size()获得map中映射的对数。</span><br><span class="line"></span><br><span class="line">③erase()</span><br><span class="line">删除单个元素：</span><br><span class="line">erase(it):it为要删除的元素的迭代器</span><br><span class="line">erase(key):key为要删除的映射的键</span><br><span class="line">删除一个区间的所有元素：</span><br><span class="line">erase(left,right):删除[left,right)内所有元素</span><br><span class="line"></span><br><span class="line">④clear()</span><br><span class="line">清空map</span><br></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><blockquote><p>pair是“二元结构体”的替代品。使用时需添加<code>include&lt;utility&gt;</code>,同时要有using namespace std。</p></blockquote><ul><li>定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typename2&gt; name;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct pair&#123;</span><br><span class="line">    typename1 first;</span><br><span class="line">    typename2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,int&gt; p;make_pair(&quot;haha&quot;,5);</span><br><span class="line">pair&lt;string,int&gt; p(&quot;haha&quot;,5);</span><br></pre></td></tr></table></figure><ul><li>pair可以直接做比较运算，比较规则是先以first的大小作为标准，只有当first相等时才去判断second的大小。</li><li>所以，pair可以作为map的键值对来插入（排序）。</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><blockquote><p>set翻译为集合，是一个内部自动有序且不含重复元素的容器。使用时需添加<code>include&lt;set&gt;</code>,同时要有using namespace std。</p></blockquote><ul><li>1、定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;typename&gt; name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; st;</span><br><span class="line">set&lt;int&gt; st[100];</span><br></pre></td></tr></table></figure><p>set只能通过迭代器访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义迭代器：</span><br><span class="line">set&lt;typename&gt;::iterator it;</span><br><span class="line">然后使用*it来访问set中的元素。</span><br><span class="line">set不支持*(it+i),it&lt;st.end()的访问方式。</span><br></pre></td></tr></table></figure><ul><li>2、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">①insert()</span><br><span class="line">insert(x)用来将x插入到set中，并自动递增排序和去重。</span><br><span class="line"></span><br><span class="line">②size()</span><br><span class="line">获得set中的元素个数</span><br><span class="line"></span><br><span class="line">③find()</span><br><span class="line">find(value)是返回set中对应值为value的迭代器</span><br><span class="line"></span><br><span class="line">④clear()</span><br><span class="line">清空set中的所有元素</span><br><span class="line"></span><br><span class="line">④erase()</span><br><span class="line">删除单个元素：</span><br><span class="line">erase(it):it为要删除元素的迭代器</span><br><span class="line">earse(value):value为要删除的元素的值</span><br><span class="line">删除一个区间的所有元素：</span><br><span class="line">erase(left,right):删除[left,right)内所有元素</span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><blockquote><p>使用时需添加<code>include&lt;string&gt;</code>,同时要有using namespace std。  </p><ul><li>定义</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string name;</span><br></pre></td></tr></table></figure><ul><li>1、访问</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①像普通字符数组一样操作</span><br><span class="line">②通过迭代器</span><br><span class="line">定义迭代器：</span><br><span class="line">string::iterator it;</span><br><span class="line">然后就可以通过*it来访问string里的每一个元素。</span><br></pre></td></tr></table></figure><ul><li>2、运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法：把两个字符串直接拼接起来。</span><br><span class="line">关系：按照字典序比较两个string类型的大小。</span><br></pre></td></tr></table></figure><ul><li>3、常用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">①length()</span><br><span class="line">返回string的长度（字符个数）</span><br><span class="line"></span><br><span class="line">②size()</span><br><span class="line">与length()一样</span><br><span class="line"></span><br><span class="line">③clear()</span><br><span class="line">用来清空string中的所有元素</span><br><span class="line"></span><br><span class="line">④substr()</span><br><span class="line">substr(pos,len)返回从pos号位置开始、长度为len的子串</span><br><span class="line"></span><br><span class="line">⑤insert()</span><br><span class="line">insert(pos,string):在pos号位置插入字符串string</span><br><span class="line">insert(it,it2,it3):it为原字符串的欲插入位置；it2和it3为待插入字符串的首尾迭代器（左毕右开区间）</span><br><span class="line"></span><br><span class="line">⑥erase()</span><br><span class="line">删除单个元素：</span><br><span class="line">erase(it):it为要删除元素的迭代器</span><br><span class="line">删除一个区间内的所有元素：</span><br><span class="line">erase(left,right):删除[left,right)中的所有元素</span><br><span class="line">erase(pos,length):pos为需要删除的字符串起始位置；length为要删除的字符个数</span><br><span class="line"></span><br><span class="line">⑦find()</span><br><span class="line">str.find(str2):当str2是str的子串时，返回其在str中第一次出现的位置；否则，返回string::npos</span><br><span class="line">string::npos是一个常数，其本身的值等于-1</span><br><span class="line">str.find(str2,pos):从str的pos号位开始匹配str2，返回值同上</span><br><span class="line"></span><br><span class="line">⑧replace()</span><br><span class="line">str.replace(pos,len,str2):把str从pos号位开始、长度为len的子串替换为str2</span><br><span class="line">str.replace(it1,it2,str2):把str的迭代器it1~it2范围内（左闭右开区间）的子串替换为str2</span><br></pre></td></tr></table></figure><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><blockquote><p>algoriyhm翻译为算法提供了大量基于迭代器的非成员模版函数。要使用这些函数，需要添加<code>#include&lt;algorithm&gt;</code>，必须要有using namespace std。</p></blockquote><ul><li>1、<code>max(),min(),abs(),swap()</code></li><li>2、<code>reverse()</code>:<code>reverse(it,it2)</code>可以将数组指针在it<del>it2（左闭右开区间）之间的元素，或容器的迭代器在it</del>it2范围内的所有元素进行反转。</li><li>3、<code>next_permutation()</code>:求出一个序列在全排列中的下一个序列。</li><li>4、<code>fill()</code>：可以把数组或容器的某一段区间赋值为某个相同的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(a,a+5,123);//将a[0]到a[4]均赋值为123</span><br></pre></td></tr></table></figure><ul><li>5、<code>sort()</code>:实现排序的函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(首元素地址，尾元素地址的下一地址，比较函数);//前两个必填，没有比较函数表示堆区间元素进行递增排序</span><br></pre></td></tr></table></figure><p>如果要实现递减排序，或者对结构体（本身没有大小关系）等进行排序，就需要用到比较函数，一般写成cmp()函数。<br>递减排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(int a,int b)&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体按照x从大到小排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在STL标准容器中，只有vector、string、deque是可以用sort()的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算及标准模版库&quot;&gt;&lt;a href=&quot;#位运算及标准模版库&quot; class=&quot;headerlink&quot; title=&quot;位运算及标准模版库&quot;&gt;&lt;/a&gt;位运算及标准模版库&lt;/h1&gt;&lt;h2 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="C/C++" scheme="http://github-zhangzhenxi.github.io.git/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>备战蓝桥杯</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%A4%87%E6%88%98%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B9%8B%E6%AF%8F%E5%A4%A9%E8%8E%B7%E5%BE%97%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%A4%87%E6%88%98%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B9%8B%E6%AF%8F%E5%A4%A9%E8%8E%B7%E5%BE%97%E7%9A%84%E7%9F%A5%E8%AF%86/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:48:34.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1."></a><strong>1.</strong></h3><p>STL 中有sort函数</p><p>bool compare(int a, int b)<br>{<br>    return a &gt; b;    &#x2F;&#x2F; 逆序排列<br>    &#x2F;&#x2F; retrun a &lt; b; 顺序排列<br>}<br>sort(数组启示位置，终止位置，[compare])</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>% : 是给int类型用的取余标志<br>fmod() : 是给double类型用的取余函数 eg：fmod(n, 2) n 对 2 取余</p><p>int gcd(int a, int b)<br>{<br>    if(b &#x3D;&#x3D; &#x3D;&#x3D;0) return a;<br>    return gcd(b, a % b);<br>}</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">最小公倍数lcm(a,b)等于ab除最大公约数gcd(a,b)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    if(b==0)return a;</span><br><span class="line">    return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int x;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    int Gcd=x,Lcm=x;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        Gcd=gcd(Gcd,x);</span><br><span class="line">        Lcm=Lcm*x/gcd(Lcm,x);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d\n&quot;,Gcd,Lcm);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>lower_bound函数是查找第一个大于或等于指定数的地址(如果没有，则返回last的下一位地址)<br>upper_bound函数是返回第一个大于指定数的地址<br>lower_bound(a + 1,  a + 1 + n, b[i])</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1.&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;STL 中有sort函数&lt;/p&gt;
&lt;p&gt;bool compare(int a, int b)&lt;br&gt;{&lt;br&gt;</summary>
      
    
    
    
    
    <category term="蓝桥杯" scheme="http://github-zhangzhenxi.github.io.git/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>前缀和、差分</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:50:15.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和、差分"><a href="#前缀和、差分" class="headerlink" title="前缀和、差分"></a>前缀和、差分</h1><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p><strong>一维前缀和 —— 模板题 AcWing 795. 前缀和</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一维前缀和数组</span><br><span class="line">S[i] = a[1] + a[2] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure><p><strong>二维前缀和 —— 模板题 AcWing 796. 子矩阵的和</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建二位前缀和</span><br><span class="line">第i行第j列的前缀和</span><br><span class="line">S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+S[i][j];</span><br><span class="line"></span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</span><br></pre></td></tr></table></figure><p><strong>一维差分 —— 模板题 AcWing 797. 差分</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</span><br></pre></td></tr></table></figure><p><strong>二维差分 —— 模板题 AcWing 798. 差分矩阵</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, </span><br><span class="line">S[x2 + 1, y2 + 1] += c</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀和、差分&quot;&gt;&lt;a href=&quot;#前缀和、差分&quot; class=&quot;headerlink&quot; title=&quot;前缀和、差分&quot;&gt;&lt;/a&gt;前缀和、差分&lt;/h1&gt;&lt;h3 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划之思考</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B%EF%BC%89/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B%EF%BC%89/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:49:23.468Z</updated>
    
    <content type="html"><![CDATA[<p><strong>闫氏思考法</strong>：从<strong>集合</strong>的角度考虑动态规划问题</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_2b2ec6f209-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E6%9D%BF.jpg" alt="动态规划模板.jpg"></p><p><strong>常见划分依据：最后</strong></p><ul><li>最后一步是从<strong>上边</strong>来的 $f(i-1,j)+w(i,j)→f(i,j)$</li><li>最后一步是从<strong>左边</strong>来的$f(i,j-1)+w(i,j)→f(i,j)$</li></ul><p><strong>集合划分原则</strong></p><ul><li>不重复（仅约束属性是<strong>数量</strong>的情况，$\max$和$\min$允许划分的集合之间有重复，例如<a href="https://www.acwing.com/activity/content/code/content/512407/">最长公共子序列</a>）</li><li>不遗漏（所有属性都约束）</li></ul><p><strong>算法中的坐标系</strong></p><p>算法中的坐标系并不是数学中定义的坐标系，而是如下图所示的坐标系</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_336d63e609-%E7%AE%97%E6%B3%95%E5%9D%90%E6%A0%87%E7%B3%BB.jpg" alt="算法坐标系.jpg"></p><p><strong>与暴力搜索的区别</strong></p><p>暴搜每次只能处理一种情况，因此效率低下；而动态规划的一个状态包含了若干种情况，是满足某个条件的情况<strong>集合</strong>，每次状态转移就能涉及若干情况，因此效率更高</p><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_0f29873e09-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E9%A2%98%E7%9B%AE%E5%85%B3%E7%B3%BB.jpg" alt="动态规划-数字三角形-题目关系.jpg"></p><p><strong>模型回顾</strong></p><p>给定一个如下图所示的数字三角形，从<strong>顶部</strong>出发，在每一结点可以选择移动至其<strong>左下</strong>方的结点或移动至其<strong>右下</strong>方的结点，一直走到<strong>底层</strong>，要求找出一条<strong>路径</strong>，使路径上的数字的<strong>和最大</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        7</span><br><span class="line">      3   8</span><br><span class="line">    8   1   0</span><br><span class="line">  2   7   4   4</span><br><span class="line">4   5   2   6   5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_f026146a09-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.jpg" alt="动态规划-数字三角形.jpg"></p><p><strong>核心代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 自顶向下（未压缩f)</span><br><span class="line">const int INF = 1e9;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= n; i ++ )</span><br><span class="line">    for (int j = 0; j &lt;= i + 1; j ++ )</span><br><span class="line">        f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">f[1][1] = a[1][1];</span><br><span class="line">    for (int i = 2; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = 1; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line">int res = -INF;</span><br><span class="line">for (int j = 1; j &lt;= n; j ++ ) res = max(res, f[n][j]);</span><br></pre></td></tr></table></figure><h3 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h3><p><strong>题意</strong></p><p>网格各顶点有给定数量的花生，找一条从左上角到右下角的路径，使得路径上的花生数量之和最大。每次只能向右或向下走。</p><p><strong>思路</strong></p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_2603986e09-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%91%98%E8%8A%B1%E7%94%9F.jpg" alt="动态规划-数字三角形-摘花生.jpg"></p><p><strong>核心代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">    for (int j = 1; j &lt;= m; j ++ )</span><br><span class="line">        f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];      // max后才加w[i][j]不会影响max的选取</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, f[n][m]);</span><br></pre></td></tr></table></figure><p><strong>笔记</strong></p><ul><li>根据最后一步的来源，即<strong>上一步的方向</strong>，可将$f(i,j)$划分成两个<strong>不重复</strong>且<strong>无交集</strong>的子集$f(i-1,j)$和$f(i,j-1)$</li><li>对比数字三角形模型<ul><li>一个是三角形，一个是矩形</li><li>都只有两个方向可以走，且不能回头</li><li>都是从左上角走到右下角</li><li>都按照<strong>上一步的方向</strong>划分集合</li><li>当前步与上一步只相差一个<strong>常数</strong>，满足<strong>线性</strong>关系（线性DP）</li><li>都是求<strong>最大路径</strong>（最小路径也类似）</li></ul></li></ul><h3 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h3><p><strong>题意</strong></p><p>从$n\times n$网格的左上走到右下，最多走$2n-1$次，即最多穿过$2n-1$个格子（包括起点和终点），求一条路径，使得经过的格子数值之和最小</p><p><strong>思路</strong></p><p>当$n&#x3D;4$时，最多只能走$2n-1&#x3D;7$次，下图为一种可行的示意图，实际上当只能向下或向右走时，穿过的格子数恰好是$2n-1$。在只能往上下左右四个方向走的限制下，这是最少穿过的格子总数（可以往曼哈顿距离考虑）。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_35f5d0b609-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9%EF%BC%88%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%89.jpg" alt="动态规划-数字三角形-最低通行费（示意图）.jpg"></p><p>因此“最多走$2n-1$次”$\Rightarrow$只能向右或向下走。故此问题转变成类似<strong>摘花生</strong>的问题，但二者仍有一些差异。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_49849e0a09-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9.jpg" alt="动态规划-数字三角形-最低通行费.jpg"></p><p>二者的主要差异：本题求的是<strong>最小路径</strong>，而摘花生求的是<strong>最大路径</strong>。这个差别在代码上体现为矩阵<code>f</code>边界(<code>i==0</code>和<code>j==0</code>)初值的选取</p><ul><li>摘花生问题中，花生数量是正数，边界默认初值为0时，不影响<code>max</code>的选取；</li><li>而最低通行费问题中，如果边界初值是0，且网格的值是正数，则会影响<code>min</code>的选取，因此边界应当初始化为无穷大，例如<code>0x7f7f7f7f</code>。</li></ul><p>当把矩阵<code>f</code>初值设为无穷大后，需要单独对<code>f[1][1]</code>处理，它的值应当为<code>a[1][1]</code>，可在二重循环内单独用<code>if(i==1 &amp;&amp; j==1)</code>处理，否则<code>f[1][1]</code>会受$\infty$影响变成$\infty + a[1][1]$而出错。</p><p>当然也可以把<code>f[0][1]</code>或<code>f[1][0]</code>置为0，使得<code>f[1][1] = min(f[0][1], f[0][1]) + a[1][1] = 0 + a[1][1] = a[1][1]</code>就行，这样有个好处，循环内部不用特判，代码简洁。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_5062ba0409-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9%EF%BC%88%E7%A4%BA%E6%84%8F%E5%9B%BE3%EF%BC%89.jpg" alt="动态规划-数字三角形-最低通行费（示意图3）.jpg"></p><p><strong>实现代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110, INF = 1e9;</span><br><span class="line"></span><br><span class="line">int g[N][N], f[N][N];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">        for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;g[i][j]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for(int i = 2; i &lt;= n; i ++) f[i][0] = f[0][i] = INF;  // 画图会清晰很多</span><br><span class="line">    </span><br><span class="line">    f[1][1] = g[1][1];</span><br><span class="line">    for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">        for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = min(f[i - 1][j], f[i][j - 1]) + g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注</strong>：我没有采用y总的代码实现，虽然比较好想，但感觉代码太复杂…</p><h3 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h3><p><strong>题意</strong>：在$n\times n$网格选两条从左上角到右下角的路径，使得二者之和最大（路径相交的格子只计一次）</p><p><strong>思路</strong></p><p>可以用两组坐标，即4个参数表示两条路径的状态，由于每条路径是独立的，且只能往下或往右走，故可划分为4类，如下图所示。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_72caa8c209-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0.jpg" alt="动态规划-数字三角形-方格取数.jpg"></p><p>当两条路径的横纵坐标之和相等时，才<strong>可能</strong>在当前位置相交，此时满足$i_1+j_1&#x3D;i_2+j_2$。</p><p>若令$i_1+j_1&#x3D;i_2+j_2&#x3D;k$，则只用3个参数$i_1,j_1,k$就能表示$i_1,j_1,i_2,j_2$，其中$j_1&#x3D;k-i_1$，$j_2&#x3D;k-i_2$。$k$既表示从$(1,1)$到$(i_1,j_1)$的横纵坐标之和，又表示从$(1,1)$到$(i_2,j_2)$的横纵坐标之和。当$k$不变时，若$i_1&#x3D;i_2$，则$j_1&#x3D;j_2$，即两条路径相交于$(i_1,j_1)$。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/10/08/45680_7914eb3409-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B02.jpg" alt="动态规划-数字三角形-方格取数2.jpg"></p><p><strong>核心代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int w[N][N];</span><br><span class="line">int f[N * 2][N][N];     // k最大取2N</span><br><span class="line"></span><br><span class="line">// main</span><br><span class="line">for (int k = 2; k &lt;= n + n; k ++ )</span><br><span class="line">    for (int i1 = 1; i1 &lt;= n; i1 ++ )</span><br><span class="line">        for (int i2 = 1; i2 &lt;= n; i2 ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            int j1 = k - i1, j2 = k - i2;</span><br><span class="line">            if (j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                // 提前算好增量，减少代码量</span><br><span class="line">                int t = w[i1][j1];                      // 相交时有w[i1][j1]==w[i2][j2]，只需记录一次</span><br><span class="line">                if (i1 != i2) t += w[i2][j2];           // 若不相交，则还要记录w[i2][j2]</span><br><span class="line"></span><br><span class="line">                int &amp;x = f[k][i1][i2];                  // 用x表示f[k][i1][i2]，减少代码长度</span><br><span class="line">                x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);       // 第1条路径来自上边，第2条路径来自上边</span><br><span class="line">                x = max(x, f[k - 1][i1 - 1][i2] + t);           // 第1条路径来自上边，第2条路径来自左边</span><br><span class="line">                x = max(x, f[k - 1][i1][i2 - 1] + t);           // 第1条路径来自左边，第2条路径来自上边</span><br><span class="line">                x = max(x, f[k - 1][i1][i2] + t);               // 第1条路径来自左边，第2条路径来自左边</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, f[n + n][n][n]);</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>由于是<strong>最大</strong>路径，且格子上的数是非负数，故矩阵<code>f</code>可以使用默认值<code>0</code>初始化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;闫氏思考法&lt;/strong&gt;：从&lt;strong&gt;集合&lt;/strong&gt;的角度考虑动态规划问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.acwing.com/media/article/image/2020/10/08/45680_2b2ec</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:49:08.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><p>动态规划的时间复杂度是 O(mn)</p></li><li><h2 id="动态规划的特点"><a href="#动态规划的特点" class="headerlink" title="动态规划的特点"></a>动态规划的特点</h2><ol><li>最优子结构（一个大问题的最优解一定包含子问题的最优解）</li><li>重叠子问题（子问题很多重复）</li><li>无后效性（当计算后面的值时，不会影响之前的计算）<br></li></ol></li><li><h2 id="动态规划题目特点："><a href="#动态规划题目特点：" class="headerlink" title="动态规划题目特点："></a>动态规划题目特点：</h2><ol><li><p><strong>计数</strong></p><ol><li>有多少种方式走到右下角     </li><li>有多少中方式选出K个数使得和是Sum</li></ol></li><li><p><strong>求最大最小值</strong></p><ol><li>从左上角走到右下角路径的最大数字和 </li><li>最长上升子序列长度</li></ol></li><li><p><strong>求存在性</strong></p><ol><li>取石子游戏，先手是否必胜  </li><li>能不能选出k个数使得和是Sum</li></ol></li></ol></li></ul><br>##    动态规划组成部分<h3 id="1-确认状态（当我们为了解决问题而设置的变量，确定他们所代表什么）"><a href="#1-确认状态（当我们为了解决问题而设置的变量，确定他们所代表什么）" class="headerlink" title="1. 确认状态（当我们为了解决问题而设置的变量，确定他们所代表什么）"></a>1. 确认状态（当我们为了解决问题而设置的变量，确定他们所代表什么）</h3><h5 id="集合（思考用几维来表示状态，要求不重复、不遗漏）"><a href="#集合（思考用几维来表示状态，要求不重复、不遗漏）" class="headerlink" title="集合（思考用几维来表示状态，要求不重复、不遗漏）"></a>集合（思考用几维来表示状态，要求不重复、不遗漏）</h5><p>  可以从这两个角度考虑：<strong>最后一步(最优策略中的最后一步)、  子问题</strong></p><h5 id="属性（决定属性的通常就是题目要求，【max-min-count】"><a href="#属性（决定属性的通常就是题目要求，【max-min-count】" class="headerlink" title="属性（决定属性的通常就是题目要求，【max | min | count】)"></a>属性（决定属性的通常就是题目要求，【max | min | count】)</h5><h3 id="2-状态计算（将集合拆分）"><a href="#2-状态计算（将集合拆分）" class="headerlink" title="2. 状态计算（将集合拆分）"></a>2. 状态计算（将集合拆分）</h3><p>**初始条件和边界问题<br>        1. 要考虑是否存在越界问题、终结条件以及用转移方程算出来的初始条件（最小值），如果不能拼出，那等于正无穷</p><p>**计算顺序<br>        1. 如何判断：当我计算时，我需要的数据已经经过前面的计算算出即可。</p><h3 id="3-成系统的分类"><a href="#3-成系统的分类" class="headerlink" title="3. 成系统的分类"></a>3. 成系统的分类</h3><h4 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h4><p>[[动态规划（背包模型）]]</p><h4 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h4><p>[[动态规划（数字三角形模型）]]</p><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><h2 id="闫氏动态分析法"><a href="#闫氏动态分析法" class="headerlink" title="闫氏动态分析法"></a>闫氏动态分析法</h2><p>![[Pasted image 20220304103506.png]]</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><pre><code>    ![[Pasted image 20220120162918.png]]    ![[Pasted image 20220120162949.png]]    ![[Pasted image 20220120163018.png]]    ![[Pasted image 20220120163305.png]]    ![[Pasted image 20220120163340.png]]    ![[Pasted image 20220120163435.png]]    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态规划的时间复杂度是 O(mn)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;动态规划的特点&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从零了解并查集</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:48:41.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零了解并查集"><a href="#从零了解并查集" class="headerlink" title="从零了解并查集"></a>从零了解并查集</h1><h3 id="并查集是什么"><a href="#并查集是什么" class="headerlink" title="并查集是什么"></a>并查集是什么</h3><p> 并查集，是一种判断“<strong>远房亲戚</strong>”的算法</p><p> 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><h3 id="并查集的作用"><a href="#并查集的作用" class="headerlink" title="并查集的作用"></a>并查集的作用</h3><p>  “并”：把两个处在同一个连通分量的结点给并到一起.</p><p> “查”：查找一个结点的根节点（询问两个元素是否在同一个集合里）</p><p> “并”的时候需要用到“查”</p><h3 id="并查集的基本原理"><a href="#并查集的基本原理" class="headerlink" title="并查集的基本原理"></a>并查集的基本原理</h3><p> 每一个集合用一个树的形式来维护所有的集合，根节点的编号是当前集合的编号，每一个节点都存储其父节点是谁（p[x]表示x的父节点，树根的父节点是它自身）</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><h6 id="1-朴素并查集："><a href="#1-朴素并查集：" class="headerlink" title="(1)朴素并查集："></a>(1)朴素并查集：</h6><p> int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点</p><p> &#x2F;&#x2F; 返回x的祖宗节点并路径压缩</p><p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (p[x] != x) p[x] = find(p[x]);</span><br><span class="line"></span><br><span class="line">        return p[x];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> &#x2F;&#x2F; 初始化，假定节点编号是1~n</p><p>    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;</p><p> &#x2F;&#x2F; 合并a和b所在的两个集合：</p><p>    p[find(a)] &#x3D; find(b);</p><h6 id="2-维护size的并查集："><a href="#2-维护size的并查集：" class="headerlink" title="(2)维护size的并查集："></a>(2)维护size的并查集：</h6><p>    int p[N], size[N];</p><p> &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</p><p> &#x2F;&#x2F; 返回x的祖宗节点</p><p>    int find(int x)</p><p>    {</p><p>        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);</p><p>        return p[x];</p><p>    }</p><p> &#x2F;&#x2F; 初始化，假定节点编号是1~n</p><p>    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p><p>    {</p><p>        p[i] &#x3D; i;</p><p>        size[i] &#x3D; 1;</p><p>    }</p><p> &#x2F;&#x2F; 合并a和b所在的两个集合：</p><p>    size[find(b)] +&#x3D; size[find(a)];</p><p>    p[find(a)] &#x3D; find(b);</p><h6 id="3-维护到祖宗节点距离的并查集："><a href="#3-维护到祖宗节点距离的并查集：" class="headerlink" title="(3)维护到祖宗节点距离的并查集："></a>(3)维护到祖宗节点距离的并查集：</h6><p>    int p[N], d[N];</p><p> &#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</p><p> &#x2F;&#x2F; 返回x的祖宗节点</p><p>    int find(int x)</p><p>    {</p><p>        if (p[x] !&#x3D; x)</p><p>        {</p><p>            int u &#x3D; find(p[x]);</p><p>            d[x] +&#x3D; d[p[x]];</p><p>            p[x] &#x3D; u;</p><p>        }</p><p>        return p[x];</p><p>    }</p><p> &#x2F;&#x2F; 初始化，假定节点编号是1~n</p><p>    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p><p>    {</p><p>        p[i] &#x3D; i;</p><p>        d[i] &#x3D; 0;</p><p>    }</p><p> &#x2F;&#x2F; 合并a和b所在的两个集合：</p><p>    p[find(a)] &#x3D; find(b);</p><p> d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从零了解并查集&quot;&gt;&lt;a href=&quot;#从零了解并查集&quot; class=&quot;headerlink&quot; title=&quot;从零了解并查集&quot;&gt;&lt;/a&gt;从零了解并查集&lt;/h1&gt;&lt;h3 id=&quot;并查集是什么&quot;&gt;&lt;a href=&quot;#并查集是什么&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://github-zhangzhenxi.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:49:44.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ul><li><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>  将两个或多个有序序列合并为一个有序序列</p><p>  注：</p><p>  二叉树的第 h 层最多有 2^h-1^ 个结点，若树高为 h ，则应该满足 n &lt;&#x3D; 2^h-1^ , 即 h−1&#x3D;⌈log2n⌉h−1&#x3D;⌈log2n⌉, 即趟数 &#x3D; ⌈log2n⌉⌈log2n⌉</p><p>  每趟归并时间复杂度为 O(n)O(n) ,则算法时间复杂度为 O(nlogn)O(nlogn)</p><p>  空间复杂度为 O(n)O(n) ,来自于辅助数组</p></li><li><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>  最好 — O（nlogn）O（nlogn）</p><p>  最坏 — O(nlogn)O(nlogn)</p><p>  平均 — O（nlogn）O（nlogn）</p><p>  注：</p><p>  归并排序分割子序列与初始序列无关，因此它的最好、最坏、平均时间复杂度均为 O（nlogn）O（nlogn）</p></li><li><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>  需要一个辅助数组 —- O（n）O（n）</p></li><li><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>  稳定</p></li><li><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>  顺序表</p><p>  链表</p></li><li><h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><p>  稳定排序</p><p>  可用于顺序结构，也可用于链式结构。使用链式结构不需要附加的存储空间，但递归实现时仍需要开辟相应的递归工作栈。</p><p>  一般而言，对于 nn 个元素进行 kk 路归并排序时，排序的趟数 mm 满足 km&#x3D;nkm&#x3D;n, 从而 m&#x3D;logknm&#x3D;logkn ，又考虑到 mm为整数，所以m&#x3D;⌈logkn⌉m&#x3D;⌈logkn⌉</p></li><li><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void merge_sort(int q[], int l, int r)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> int tmp[N];</span><br><span class="line"></span><br><span class="line"> if (l &gt;= r) return; //查看是否越界</span><br><span class="line"> </span><br><span class="line"> int mid = （l + r） &gt;&gt; 1;//归并排序是以中间点为分解，而不是快速排序依赖的数值</span><br><span class="line"></span><br><span class="line"> merge_sort(q, l, mid);</span><br><span class="line"></span><br><span class="line"> merge_sort(q, mid + 1, r);</span><br><span class="line"></span><br><span class="line">//递归处理</span><br><span class="line"></span><br><span class="line"> int k = 0, i = l, j = mid + 1;</span><br><span class="line"></span><br><span class="line"> while (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line"></span><br><span class="line"> if (q[i] &lt;= q[j])  tmp[k ++ ] = q[i ++ ];</span><br><span class="line"></span><br><span class="line"> else tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">//将 a[low ... mid] 和 a[mid + 1 ...high]归并</span><br><span class="line"></span><br><span class="line"> while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line"></span><br><span class="line"> while (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">//当只有一个指针到最后时，这两条代码能够将剩下的值归并</span><br><span class="line"></span><br><span class="line"> for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line"></span><br><span class="line">//将数组的值给要返回数组中</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e3 + 10;</span><br><span class="line"></span><br><span class="line">void merge_sort(int q[], int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">int tmp[N];</span><br><span class="line"></span><br><span class="line">if(l &gt;= r) return;</span><br><span class="line"></span><br><span class="line">int mid = (l + r) &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">merge_sort(q, l, mid);</span><br><span class="line"></span><br><span class="line">merge_sort(q, mid + 1, r);</span><br><span class="line"></span><br><span class="line">int k = 0, i = l, j = mid + 1;</span><br><span class="line"></span><br><span class="line">while(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">if(q[i] &lt; q[j]) tmp[k ++] = q[i ++];</span><br><span class="line">else tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">while(i &lt;= mid) tmp[k ++] = q[i ++];</span><br><span class="line"></span><br><span class="line">while(j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">for(int i = l, j = 0; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= 10; i ++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">merge_sort(a, 1, 10);</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= 10; i ++) printf(&quot;%d  &quot;, a[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://github-zhangzhenxi.github.io.git/2022/10/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2022-10-03T12:40:52.000Z</published>
    <updated>2022-10-05T07:51:23.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="-   算法思想"></a>-   算法思想</h3><pre><code>在待排序表 a[0...n-1]中任取一个元素pivot作为枢轴（或基准，通常取首元素）,通过一趟排序将待排序表划分为独立的两个部分a[0...k-1]和a[k + 1 ...n-1]，使得a[0...k-1]中的所有元素均小于pivot,a[k + 1...n - 1]中所有元素均大于等于pivot,则pivot放在其最终的位置a[k]上,这一过程成为一次“划分”，然后分别递归地对两个子表重复上述过程，直到每一部分内只有一个元素或空为止，即所有元素放在了其最终的位置上。</code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="-   时间复杂度"></a>-   时间复杂度</h3><pre><code>最好 — O(nlogn)O(nlogn) 序列均匀分割最坏 — O(n2)O(n2) 序列有序平均 — O(nlogn)O(nlogn)</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="-   空间复杂度"></a>-   空间复杂度</h3><pre><code>最好 — O(nlogn)O(nlogn) 序列均匀分割最坏 — O(n)O(n) 序列有序</code></pre><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="-   稳定性"></a>-   稳定性</h3><pre><code>不稳定</code></pre><h3 id="适用性"><a href="#适用性" class="headerlink" title="-   适用性"></a>-   适用性</h3><pre><code>仅适用于顺序表</code></pre><h3 id="算法特点"><a href="#算法特点" class="headerlink" title="-   算法特点"></a>-   算法特点</h3><pre><code>当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n较大时的情况记录非顺次的移动导致排序方法是不稳定的排序过程中需要定位表的上界和下界，所以仅适合于顺序结构，很难适用于链式结构</code></pre><h3 id="快速排序进行的步骤：判断是否进行、确定分界点（中间值、左边界和有边界）、处理左右区间、递归"><a href="#快速排序进行的步骤：判断是否进行、确定分界点（中间值、左边界和有边界）、处理左右区间、递归" class="headerlink" title="-   快速排序进行的步骤：判断是否进行、确定分界点（中间值、左边界和有边界）、处理左右区间、递归"></a>-   快速排序进行的步骤：判断是否进行、确定分界点（中间值、左边界和有边界）、处理左右区间、递归</h3><h3 id="快速排序的模板："><a href="#快速排序的模板：" class="headerlink" title="-   快速排序的模板："></a>-   快速排序的模板：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int q[], int l, int r)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> if(l &gt;= r) return;</span><br><span class="line"></span><br><span class="line"> int x = q[l], i = l - 1, j = r + 1;</span><br><span class="line"></span><br><span class="line"> while(i &lt; j)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> do i ++; while(q[i] &lt; x);</span><br><span class="line"></span><br><span class="line"> do j --; while(q[j] &gt; x);</span><br><span class="line"></span><br><span class="line"> if(i &lt; j) swap(q[i], q[j]);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> quick_sort(q, l, j);</span><br><span class="line"></span><br><span class="line"> quick_sort(q, j + 1, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;-   算法思想&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github-zhangzhenxi.github.io.git/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
